beta[1] <- median(r0)
# ---- Update slopes
for (j in 2:p) {
rj <- y - X[ , -j, drop = FALSE] %*% beta[-j]  # partial residual
z <- rj / X[, j]
w <- abs(X[, j])
beta[j] <- wmedian(z, w)
}
## computing the losses
r <- y - X %*% beta
mae.loss[iter] <- mean(abs(r))
# Convergence check
if (sum(abs(beta - beta_old)) < tol) break
}
return(list(
beta = beta,
mae.loss = mae.loss
))
}
# ---------- Boston Housing Example ----------
data(Boston)
y <- Boston$medv
X <- as.matrix(cbind(1, Boston[ , -which(names(Boston)=="medv")]))  # add intercept
# Fit LAD via coordinate descent
set.seed(123)
beta_hat <- LAD_CD(X, y, max_iter = 200)$beta
print("Estimated coefficients:")
print(beta_hat)
# ---------- Compare against quantreg (LP-based LAD) ----------
library(quantreg)
rq_fit <- rq(medv ~ ., data = Boston, method = "br")
print("quantreg coefficients (check consistency):")
print(coef(rq_fit))
## Diff between the 2 methods
sum(abs(beta_hat - coef(rq_fit)))
y_pred_cd <- X %*% beta_hat
y_pred_rq <- predict(rq_fit, newdata = Boston)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
c(LAD_CD = mae_cd, QuantReg = mae_rq)
system.time(LAD_CD(X, y, max_iter = 200))
system.time(rq(medv ~ ., data = Boston, method = "br"))
# ---------- Visualization ----------
y_hat <- X %*% beta_hat
plot(y, y_hat, main = "Boston Housing: LAD CD Fit vs. True",
xlab = "True MEDV", ylab = "Predicted MEDV", pch = 20, col = "blue")
abline(0, 1, col = "red", lwd = 2)
## MAE loss over iterations
lad_fit <- LAD_CD(X, y, max_iter = 200)
plot(lad_fit$mae.loss, type = "b", pch = 20, col = "blue",
xlab = "Iteration", ylab = "MAE Loss", main = "MAE Loss over Iterations",
ylim = c(min(lad_fit$mae.loss, mae_rq) * 0.9, max(lad_fit$mae.loss, mae_rq) * 1.1))
abline(h = mae_rq, col = "red", lwd = 2, lty = 2)
legend("topright", legend = c("LAD CD", "QuantReg MAE"),
col = c("blue", "red"), pch = c(20, NA), lty = c(1, 2), lwd = c(1, 2))
points(y, y_pred_rq, col = "green", pch = 17)
y_hat <- X %*% beta_hat
plot(y, y_hat, main = "Boston Housing: LAD CD Fit vs. True",
xlab = "True MEDV", ylab = "Predicted MEDV", pch = 20, col = "blue")
points(y, y_pred_rq, col = "green", pch = 17)
abline(0, 1, col = "red", lwd = 2)
legend("topleft", legend = c("LAD CD", "QuantReg"),
col = c("blue", "green"), pch = c(20, 17))
# ---------- Visualization ----------
y_hat <- X %*% beta_hat
plot(y, y_hat, main = "Boston Housing: LAD CD Fit vs. True",
xlab = "True MEDV", ylab = "Predicted MEDV", pch = 20, col = "blue")
points(y, y_pred_rq, col = "green", pch = 17, cex = 0.7)
abline(0, 1, col = "red", lwd = 2)
legend("topleft", legend = c("LAD CD Predictions", "QuantReg Predictions"),
col = c("blue", "green"), pch = c(20, 17))
## MAE loss over iterations
lad_fit <- LAD_CD(X, y, max_iter = 200)
plot(lad_fit$mae.loss, type = "b", pch = 20, col = "blue",
xlab = "Iteration", ylab = "MAE Loss", main = "MAE Loss over Iterations",
ylim = c(min(lad_fit$mae.loss, mae_rq) * 0.9, max(lad_fit$mae.loss, mae_rq) * 1.1))
abline(h = mae_rq, col = "red", lwd = 2, lty = 2)
legend("topright", legend = c("LAD CD", "QuantReg MAE"),
col = c("blue", "red"), pch = c(20, NA), lty = c(1, 2), lwd = c(1, 2))
## ===============================
## Coordinate Descent for LAD in R
## ===============================
# Load packages
library(MASS)       # for Boston dataset
library(matrixStats) # for weightedMedian
# ---------- Algorithm Implementation ----------
LAD_CD <- function(X, y, max_iter = 100, tol = 1e-6) {
n <- nrow(X)
p <- ncol(X)
# Initialize beta (zeros)
beta <- rep(0, p)
# Helper function: weighted median
wmedian <- function(z, w) {
matrixStats::weightedMedian(z, w = w)
}
mae.loss <- numeric(max_iter)
for (iter in 1:max_iter) {
beta_old <- beta
# ---- Update intercept (first column is 1 for intercept)
r0 <- y - X[ , -1, drop = FALSE] %*% beta[-1]
beta[1] <- median(r0)
# ---- Update slopes
for (j in 2:p) {
rj <- y - X[ , -j, drop = FALSE] %*% beta[-j]  # partial residual
z <- rj / X[, j]
w <- abs(X[, j])
beta[j] <- wmedian(z, w)
}
## computing the losses
r <- y - X %*% beta
mae.loss[iter] <- mean(abs(r))
# Convergence check
if (sum(abs(beta - beta_old)) < tol) break
}
return(list(
beta = beta,
mae.loss = mae.loss
))
}
# ---------- Boston Housing Example ----------
data(Boston)
y <- Boston$medv
X <- as.matrix(cbind(1, Boston[ , -which(names(Boston)=="medv")]))  # add intercept
# Fit LAD via coordinate descent
set.seed(123)
max_iter <- 400
beta_hat <- LAD_CD(X, y, max_iter = max_iter)$beta
print("Estimated coefficients:")
print(beta_hat)
# ---------- Compare against quantreg (LP-based LAD) ----------
library(quantreg)
rq_fit <- rq(medv ~ ., data = Boston, method = "br")
print("quantreg coefficients (check consistency):")
print(coef(rq_fit))
## Diff between the 2 methods
sum(abs(beta_hat - coef(rq_fit)))
y_pred_cd <- X %*% beta_hat
y_pred_rq <- predict(rq_fit, newdata = Boston)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
c(LAD_CD = mae_cd, QuantReg = mae_rq)
system.time(LAD_CD(X, y, max_iter = max_iter))
system.time(rq(medv ~ ., data = Boston, method = "br"))
# ---------- Visualization ----------
y_hat <- X %*% beta_hat
plot(y, y_hat, main = "Boston Housing: LAD CD Fit vs. True",
xlab = "True MEDV", ylab = "Predicted MEDV", pch = 20, col = "blue")
points(y, y_pred_rq, col = "green", pch = 17, cex = 0.7)
abline(0, 1, col = "red", lwd = 2)
legend("topleft", legend = c("LAD CD Predictions", "QuantReg Predictions"),
col = c("blue", "green"), pch = c(20, 17))
## MAE loss over iterations
lad_fit <- LAD_CD(X, y, max_iter = max_iter)
plot(lad_fit$mae.loss, type = "b", pch = 20, col = "blue",
xlab = "Iteration", ylab = "MAE Loss", main = "MAE Loss over Iterations",
ylim = c(min(lad_fit$mae.loss, mae_rq) * 0.9, max(lad_fit$mae.loss, mae_rq) * 1.1))
abline(h = mae_rq, col = "red", lwd = 2, lty = 2)
legend("topright", legend = c("LAD CD MAE", "QuantReg MAE"),
col = c("blue", "red"), pch = c(20, NA), lty = c(1, 2), lwd = c(1, 2))
plot(y, y_hat, main = "Boston Housing: LAD CD Fit vs. QuantReg Fit",
xlab = "True MEDV", ylab = "Predicted MEDV", pch = 20, col = "blue")
points(y, y_pred_rq, col = "green", pch = 17, cex = 0.7)
abline(0, 1, col = "red", lwd = 2)
legend("topleft", legend = c("LAD CD Predictions", "QuantReg Predictions"),
col = c("blue", "green"), pch = c(20, 17))
# Check for zeros in predictors
colSums(Boston == 0)
# Check if your predictions correlate with rq predictions
cor(y_pred_cd, y_pred_rq)
# Try scaling predictors
X_scaled <- scale(Boston[ , -which(names(Boston)=="medv")])
X_scaled <- cbind(1, X_scaled)
beta_hat_scaled <- LAD_CD(X_scaled, y, max_iter = 100)
## ===============================
## LAD vs QuantReg on AirQuality
## ===============================
library(datasets)
library(quantreg)
library(matrixStats)
# ---------- LAD Coordinate Descent Implementation ----------
LAD_CD <- function(X, y, max_iter = 500, tol = 1e-6) {
n <- nrow(X)
p <- ncol(X)
beta <- rep(0, p)
wmedian <- function(z, w) {
matrixStats::weightedMedian(z, w = w)
}
loss_hist <- numeric(max_iter)
for (iter in 1:max_iter) {
beta_old <- beta
# Intercept update
r0 <- y - X[, -1, drop = FALSE] %*% beta[-1]
beta[1] <- median(r0)
# Slopes
for (j in 2:p) {
xj <- X[, j]
nz <- which(xj != 0)  # avoid division by zero
rj <- y - X[, -j, drop = FALSE] %*% beta[-j]
z <- rj[nz] / xj[nz]
w <- abs(xj[nz])
beta[j] <- wmedian(z, w)
}
# Store loss
y_pred <- X %*% beta
loss_hist[iter] <- mean(abs(y - y_pred))
# Convergence check
if (sum(abs(beta - beta_old)) < tol) {
loss_hist <- loss_hist[1:iter]
break
}
}
list(beta = beta, loss = loss_hist)
}
# ---------- Air Quality Data ----------
data("airquality")
df <- na.omit(airquality)   # remove missing rows
y <- df$Ozone
X <- as.matrix(cbind(1, df[, -which(names(df) == "Ozone")]))
# ---------- Fit Models ----------
set.seed(123)
t1 <- system.time(fit_cd <- LAD_CD(X, y, max_iter = 500))
beta_cd <- fit_cd$beta
loss_cd <- fit_cd$loss
t2 <- system.time(fit_rq <- rq(Ozone ~ ., data = df, method = "br"))
beta_rq <- coef(fit_rq)
# ---------- Predictions & MAE ----------
y_pred_cd <- X %*% beta_cd
y_pred_rq <- predict(fit_rq, newdata = df)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
coef_dist <- sum(abs(beta_cd - beta_rq))
cat("MAE LAD_CD:", mae_cd, "\n")
cat("MAE QuantReg:", mae_rq, "\n")
cat("Coefficient distance:", coef_dist, "\n")
cat("Runtime LAD_CD:", t1["elapsed"], "s\n")
cat("Runtime QuantReg:", t2["elapsed"], "s\n")
# ---------- Plots ----------
par(mfrow=c(1,2))
# Pred vs True
plot(y, y_pred_cd, col="blue", pch=20,
xlab="True Ozone", ylab="Predicted Ozone",
main="Air Quality: LAD CD vs QuantReg")
points(y, y_pred_rq, col="green3", pch=17)
abline(0,1,col="red", lwd=2)
legend("topleft", legend=c("LAD CD", "QuantReg"),
col=c("blue","green3"), pch=c(20,17))
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss")
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
mae_rq
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss",
ylim=c(min(c(loss_cd, mae_rq)), max(loss_cd)))
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss",
ylim=c(min(c(loss_cd, mae_rq)), max(loss_cd)))
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
par(mfrow = c(1,1))
## ===============================
## LAD vs QuantReg on AirQuality
## ===============================
library(datasets)
library(quantreg)
library(matrixStats)
# ---------- LAD Coordinate Descent Implementation ----------
LAD_CD <- function(X, y, max_iter = 500, tol = 1e-6) {
n <- nrow(X)
p <- ncol(X)
beta <- rep(0, p)
wmedian <- function(z, w) {
matrixStats::weightedMedian(z, w = w)
}
loss_hist <- numeric(max_iter)
for (iter in 1:max_iter) {
beta_old <- beta
# Intercept update
r0 <- y - X[, -1, drop = FALSE] %*% beta[-1]
beta[1] <- median(r0)
# Slopes
for (j in 2:p) {
xj <- X[, j]
nz <- which(xj != 0)  # avoid division by zero
rj <- y - X[, -j, drop = FALSE] %*% beta[-j]
z <- rj[nz] / xj[nz]
w <- abs(xj[nz])
beta[j] <- wmedian(z, w)
}
# Store loss
y_pred <- X %*% beta
loss_hist[iter] <- mean(abs(y - y_pred))
# Convergence check
if (sum(abs(beta - beta_old)) < tol) {
loss_hist <- loss_hist[1:iter]
break
}
}
list(beta = beta, loss = loss_hist)
}
# ---------- Air Quality Data ----------
data("airquality")
df <- na.omit(airquality)   # remove missing rows
y <- df$Ozone
X <- as.matrix(cbind(1, df[, -which(names(df) == "Ozone")]))
# ---------- Fit Models ----------
set.seed(123)
t1 <- system.time(fit_cd <- LAD_CD(X, y, max_iter = 500))
beta_cd <- fit_cd$beta
loss_cd <- fit_cd$loss
t2 <- system.time(fit_rq <- rq(Ozone ~ ., data = df, method = "br"))
beta_rq <- coef(fit_rq)
# ---------- Predictions & MAE ----------
y_pred_cd <- X %*% beta_cd
y_pred_rq <- predict(fit_rq, newdata = df)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
coef_dist <- sum(abs(beta_cd - beta_rq))
cat("MAE LAD_CD:", mae_cd, "\n")
cat("MAE QuantReg:", mae_rq, "\n")
cat("Coefficient distance:", coef_dist, "\n")
cat("Runtime LAD_CD:", t1["elapsed"], "s\n")
cat("Runtime QuantReg:", t2["elapsed"], "s\n")
# ---------- Plots ----------
# Pred vs True
plot(y, y_pred_cd, col="blue", pch=20,
xlab="True Ozone", ylab="Predicted Ozone",
main="Air Quality: LAD CD vs QuantReg")
points(y, y_pred_rq, col="green3", pch=17)
abline(0,1,col="red", lwd=2)
legend("topleft", legend=c("LAD CD", "QuantReg"),
col=c("blue","green3"), pch=c(20,17))
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss",
ylim=c(min(c(loss_cd, mae_rq)), max(loss_cd)))
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
## ===============================
## LAD vs QuantReg on Concrete Strength
## ===============================
library(readxl)
library(quantreg)
library(matrixStats)
# ---------- LAD Coordinate Descent Implementation ----------
LAD_CD <- function(X, y, max_iter = 500, tol = 1e-6) {
n <- nrow(X)
p <- ncol(X)
beta <- rep(0, p)
wmedian <- function(z, w) {
matrixStats::weightedMedian(z, w = w)
}
loss_hist <- numeric(max_iter)
for (iter in 1:max_iter) {
beta_old <- beta
# Intercept update
r0 <- y - X[, -1, drop = FALSE] %*% beta[-1]
beta[1] <- median(r0)
# Slopes
for (j in 2:p) {
xj <- X[, j]
nz <- which(xj != 0)
rj <- y - X[, -j, drop = FALSE] %*% beta[-j]
z <- rj[nz] / xj[nz]
w <- abs(xj[nz])
beta[j] <- wmedian(z, w)
}
y_pred <- X %*% beta
loss_hist[iter] <- mean(abs(y - y_pred))
if (sum(abs(beta - beta_old)) < tol) {
loss_hist <- loss_hist[1:iter]
break
}
}
list(beta = beta, loss = loss_hist)
}
# ---------- Load Concrete Data ----------
# Download from UCI: https://archive.ics.uci.edu/ml/datasets/concrete+compressive+strength
# Suppose saved locally as "Concrete_Data.xls"
df <- read_excel("Concrete_Data.xls")
names(df) <- c("Cement", "Slag", "FlyAsh", "Water", "SP", "CoarseAgg", "FineAgg", "Age", "Strength")
y <- df$Strength
X <- as.matrix(cbind(1, df[, -which(names(df) == "Strength")]))  # add intercept
# ---------- Fit Models ----------
set.seed(123)
t1 <- system.time(fit_cd <- LAD_CD(X, y, max_iter = 500))
beta_cd <- fit_cd$beta
loss_cd <- fit_cd$loss
t2 <- system.time(fit_rq <- rq(Strength ~ ., data = df, method = "br"))
beta_rq <- coef(fit_rq)
# ---------- Predictions & MAE ----------
y_pred_cd <- X %*% beta_cd
y_pred_rq <- predict(fit_rq, newdata = df)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
coef_dist <- sum(abs(beta_cd - beta_rq))
cat("MAE LAD_CD:", mae_cd, "\n")
cat("MAE QuantReg:", mae_rq, "\n")
cat("Coefficient distance:", coef_dist, "\n")
cat("Runtime LAD_CD:", t1["elapsed"], "s\n")
cat("Runtime QuantReg:", t2["elapsed"], "s\n")
# ---------- Plots ----------
par(mfrow=c(1,2))
# Pred vs True
plot(y, y_pred_cd, col="blue", pch=20,
xlab="True Strength", ylab="Predicted Strength",
main="Concrete: LAD CD vs QuantReg")
points(y, y_pred_rq, col="green3", pch=17)
abline(0,1,col="red", lwd=2)
legend("topleft", legend=c("LAD CD", "QuantReg"),
col=c("blue","green3"), pch=c(20,17))
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss")
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
# ---------- Plots ----------
par(mfrow=c(1,1))
## ===============================
## LAD vs QuantReg on Concrete Strength
## ===============================
library(readxl)
library(quantreg)
library(matrixStats)
# ---------- LAD Coordinate Descent Implementation ----------
LAD_CD <- function(X, y, max_iter = 500, tol = 1e-6) {
n <- nrow(X)
p <- ncol(X)
beta <- rep(0, p)
wmedian <- function(z, w) {
matrixStats::weightedMedian(z, w = w)
}
loss_hist <- numeric(max_iter)
for (iter in 1:max_iter) {
beta_old <- beta
# Intercept update
r0 <- y - X[, -1, drop = FALSE] %*% beta[-1]
beta[1] <- median(r0)
# Slopes
for (j in 2:p) {
xj <- X[, j]
nz <- which(xj != 0)
rj <- y - X[, -j, drop = FALSE] %*% beta[-j]
z <- rj[nz] / xj[nz]
w <- abs(xj[nz])
beta[j] <- wmedian(z, w)
}
y_pred <- X %*% beta
loss_hist[iter] <- mean(abs(y - y_pred))
if (sum(abs(beta - beta_old)) < tol) {
loss_hist <- loss_hist[1:iter]
break
}
}
list(beta = beta, loss = loss_hist)
}
# ---------- Load Concrete Data ----------
# Download from UCI: https://archive.ics.uci.edu/ml/datasets/concrete+compressive+strength
# Suppose saved locally as "Concrete_Data.xls"
df <- read_excel("Concrete_Data.xls")
names(df) <- c("Cement", "Slag", "FlyAsh", "Water", "SP", "CoarseAgg", "FineAgg", "Age", "Strength")
y <- df$Strength
X <- as.matrix(cbind(1, df[, -which(names(df) == "Strength")]))  # add intercept
# ---------- Fit Models ----------
set.seed(123)
t1 <- system.time(fit_cd <- LAD_CD(X, y, max_iter = 500))
beta_cd <- fit_cd$beta
loss_cd <- fit_cd$loss
t2 <- system.time(fit_rq <- rq(Strength ~ ., data = df, method = "br"))
beta_rq <- coef(fit_rq)
# ---------- Predictions & MAE ----------
y_pred_cd <- X %*% beta_cd
y_pred_rq <- predict(fit_rq, newdata = df)
mae_cd <- mean(abs(y - y_pred_cd))
mae_rq <- mean(abs(y - y_pred_rq))
coef_dist <- sum(abs(beta_cd - beta_rq))
cat("MAE LAD_CD:", mae_cd, "\n")
cat("MAE QuantReg:", mae_rq, "\n")
cat("Coefficient distance:", coef_dist, "\n")
cat("Runtime LAD_CD:", t1["elapsed"], "s\n")
cat("Runtime QuantReg:", t2["elapsed"], "s\n")
# ---------- Plots ----------
# Pred vs True
plot(y, y_pred_cd, col="blue", pch=20,
xlab="True Strength", ylab="Predicted Strength",
main="Concrete: LAD CD vs QuantReg")
points(y, y_pred_rq, col="green3", pch=17)
abline(0,1,col="red", lwd=2)
legend("topleft", legend=c("LAD CD", "QuantReg"),
col=c("blue","green3"), pch=c(20,17))
# Loss convergence
plot(loss_cd, type="o", col="blue", pch=20,
main="MAE Loss over Iterations",
xlab="Iteration", ylab="MAE Loss")
abline(h=mae_rq, col="red", lty=2, lwd=2)
legend("topright", legend=c("LAD CD MAE", "QuantReg MAE"),
col=c("blue","red"), lty=c(1,2), pch=c(20,NA))
